Description: V4: fix usage of QV4::Value tags/types
Origin: upstream, https://code.qt.io/cgit/qt/qtdeclarative.git/commit/?id=9d2169a2d8b81b87
Bug: https://bugreports.qt.io/browse/QTBUG-56471
Last-Update: 2016-10-17

--- a/src/qml/jit/qv4isel_masm.cpp
+++ b/src/qml/jit/qv4isel_masm.cpp
@@ -971,7 +971,7 @@
                 tag = QV4::Value::Integer_Type_Internal;
                 break;
             default:
-                tag = QV4::Value::Undefined_Type;
+                tag = 31337; // bogus value
                 Q_UNREACHABLE();
             }
             _as->store32(Assembler::TrustedImm32(tag), addr);
@@ -1418,7 +1418,7 @@
             Address temp = _as->loadAddress(Assembler::ScratchRegister, s->cond);
             Address tag = temp;
             tag.offset += QV4::Value::tagOffset();
-            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type));
+            Assembler::Jump booleanConversion = _as->branch32(Assembler::NotEqual, tag, Assembler::TrustedImm32(QV4::Value::Boolean_Type_Internal));
 
             Address data = temp;
             data.offset += QV4::Value::valueOffset();
@@ -1582,7 +1582,7 @@
                     tag = QV4::Value::Boolean_Type_Internal;
                     break;
                 default:
-                    tag = QV4::Value::Undefined_Type;
+                    tag = 31337; // bogus value
                     Q_UNREACHABLE();
                 }
                 _as->or64(Assembler::TrustedImm64(tag << 32),
--- a/src/qml/jsruntime/qv4arraydata.cpp
+++ b/src/qml/jsruntime/qv4arraydata.cpp
@@ -100,7 +100,7 @@
 static Q_ALWAYS_INLINE void storeValue(ReturnedValue *target, uint value)
 {
     Value v;
-    v.setTagValue(Value::fromReturnedValue(*target).tag(), value);
+    v.setEmpty(value);
     *target = v.asReturnedValue();
 }
 
@@ -189,6 +189,7 @@
     } else {
         sparse->sparse = new SparseArray;
         lastFree = &sparse->freeList;
+        storeValue(lastFree, 0);
         for (uint i = 0; i < toCopy; ++i) {
             if (!sparse->arrayData[i].isEmpty()) {
                 SparseArrayNode *n = sparse->sparse->insert(i);
@@ -209,6 +210,8 @@
         }
         storeValue(lastFree, UINT_MAX);
     }
+
+    Q_ASSERT(Value::fromReturnedValue(sparse->freeList).isEmpty());
     // ### Could explicitly free the old data
 }
 
@@ -357,12 +360,12 @@
     Value *v = d->arrayData + idx;
     if (d->attrs && d->attrs[idx].isAccessor()) {
         // double slot, free both. Order is important, so we have a double slot for allocation again afterwards.
-        v[1].setTagValue(Value::Empty_Type, Value::fromReturnedValue(d->freeList).value());
-        v[0].setTagValue(Value::Empty_Type, idx + 1);
+        v[1].setEmpty(Value::fromReturnedValue(d->freeList).emptyValue());
+        v[0].setEmpty(idx + 1);
     } else {
-        v->setTagValue(Value::Empty_Type, Value::fromReturnedValue(d->freeList).value());
+        v->setEmpty(Value::fromReturnedValue(d->freeList).emptyValue());
     }
-    d->freeList = idx;
+    d->freeList = Primitive::emptyValue(idx).asReturnedValue();
     if (d->attrs)
         d->attrs[idx].clear();
 }
@@ -400,9 +403,9 @@
             Q_ASSERT(dd->arrayData[Value::fromReturnedValue(*last).value()].value() != Value::fromReturnedValue(*last).value());
             if (dd->arrayData[Value::fromReturnedValue(*last).value()].value() == (Value::fromReturnedValue(*last).value() + 1)) {
                 // found two slots in a row
-                uint idx = Value::fromReturnedValue(*last).uint_32();
+                uint idx = Value::fromReturnedValue(*last).emptyValue();
                 Value lastV = Value::fromReturnedValue(*last);
-                lastV.setTagValue(lastV.tag(), dd->arrayData[lastV.value() + 1].value());
+                lastV.setEmpty(dd->arrayData[lastV.emptyValue() + 1].value());
                 *last = lastV.rawValue();
                 dd->attrs[idx] = Attr_Accessor;
                 return idx;
@@ -416,7 +419,8 @@
         }
         uint idx = Value::fromReturnedValue(dd->freeList).value();
         Q_ASSERT(idx != UINT_MAX);
-        dd->freeList = dd->arrayData[idx].uint_32();
+        dd->freeList = dd->arrayData[idx].asReturnedValue();
+        Q_ASSERT(Value::fromReturnedValue(dd->freeList).isEmpty());
         if (dd->attrs)
             dd->attrs[idx] = Attr_Data;
         return idx;
@@ -471,13 +475,14 @@
 
     if (isAccessor) {
         // free up both indices
-        dd->arrayData[pidx + 1].setTagValue(Value::Empty_Type, Value::fromReturnedValue(dd->freeList).value());
-        dd->arrayData[pidx].setTagValue(Value::Undefined_Type, pidx + 1);
+        dd->arrayData[pidx + 1].setEmpty(Value::fromReturnedValue(dd->freeList).emptyValue());
+        dd->arrayData[pidx].setEmpty(pidx + 1);
     } else {
-        dd->arrayData[pidx].setTagValue(Value::Empty_Type, Value::fromReturnedValue(dd->freeList).value());
+        Q_ASSERT(dd->type == Heap::ArrayData::Sparse);
+        dd->arrayData[pidx].setEmpty(Value::fromReturnedValue(dd->freeList).emptyValue());
     }
 
-    dd->freeList = pidx;
+    dd->freeList = Primitive::emptyValue(pidx).asReturnedValue();
     dd->sparse->erase(n);
     return true;
 }
--- a/src/qml/jsruntime/qv4persistent.cpp
+++ b/src/qml/jsruntime/qv4persistent.cpp
@@ -139,7 +139,7 @@
     while (p) {
         while (index < kEntriesPerPage - 1) {
             ++index;
-            if (static_cast<Page *>(p)->values[index].tag() != QV4::Value::Empty_Type)
+            if (!static_cast<Page *>(p)->values[index].isEmpty())
                 return *this;
         }
         index = -1;
--- a/src/qml/jsruntime/qv4value_p.h
+++ b/src/qml/jsruntime/qv4value_p.h
@@ -226,6 +226,17 @@
         setTagValue(Empty_Type_Internal, quint32(i));
     }
 
+    Q_ALWAYS_INLINE void setEmpty(quint32 i)
+    {
+        setTagValue(Empty_Type_Internal, i);
+    }
+
+    Q_ALWAYS_INLINE quint32 emptyValue()
+    {
+        Q_ASSERT(isEmpty());
+        return quint32(value());
+    }
+
     enum Type {
         Undefined_Type,
         Managed_Type,
@@ -530,6 +541,7 @@
 struct Q_QML_PRIVATE_EXPORT Primitive : public Value
 {
     inline static Primitive emptyValue();
+    inline static Primitive emptyValue(uint v);
     static inline Primitive fromBoolean(bool b);
     static inline Primitive fromInt32(int i);
     inline static Primitive undefinedValue();
@@ -559,6 +571,13 @@
     return v;
 }
 
+inline Primitive Primitive::emptyValue(uint e)
+{
+    Primitive v;
+    v.setEmpty(e);
+    return v;
+}
+
 inline Primitive Primitive::nullValue()
 {
     Primitive v;
--- a/src/qml/memory/qv4mm.cpp
+++ b/src/qml/memory/qv4mm.cpp
@@ -460,7 +460,7 @@
         remainingWeakQObjectWrappers.reserve(pendingCount);
         for (int i = 0; i < pendingCount; ++i) {
             Value *v = m_pendingFreedObjectWrapperValue.at(i);
-            if (v->tag() == Value::Undefined_Type)
+            if (v->isUndefined() || v->isEmpty())
                 PersistentValueStorage::free(v);
             else
                 remainingWeakQObjectWrappers.append(v);
